<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="whip1ash&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      写给0基础的CVE-2018-1270分析 | whip1ash
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>whip1ash</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>写给0基础的CVE-2018-1270分析</h2>
  <p class="post-date">2018-04-17</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="写给0基础的CVE-2018-1270分析"><a href="#写给0基础的CVE-2018-1270分析" class="headerlink" title="写给0基础的CVE-2018-1270分析"></a>写给0基础的CVE-2018-1270分析</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>自己的一些分析，比较粗浅，Spring好复杂，可能有很多错误，多多交流。文章比较长，建议使用电脑阅读。<br>由于利用环境比较特殊，所以基础知识的铺垫特别的多，熟悉Spring的同学可以直接跳到分析。</p>
<p>这个漏洞简单的说就是selector的值没有进行过滤就带进了SpEL表达式，同时SpEL表达式的权限比较高，可以执行任意命令。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>首先我们需要了解一下什么是Spring。</p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>简单的说，Spring是一个Java开源框架，一般指的是Spring Framework。但是Spring Framework的配置非常繁琐，所以在此基础上，Spring Boot诞生了，既拥有Spring Framework各种特性，又简化了各种配置。这次漏洞发生在Spring Framework中，所以Spring Boot也会受到影响。</p>
<p>首先，我们需要知道如何使用Spring。我们只需要在我们的包管理工具中把它引入就可以了（比如Maven的pom.xml）。</p>
<p>图为maven的pom.xml<br><img src="/media/15244831114337.jpg" alt="maven pom.xml"></p>
<p>影响的范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring Framework 5.0 to 5.0.4</span><br><span class="line">Spring Framework 4.3 to 4.3.14</span><br><span class="line">Spring Boot &lt; 2.0.1 RELEASE</span><br></pre></td></tr></table></figure>
<p>这次漏洞的触发的场景是<code>Spring-Messaging + WebSocket + STOMP</code>。这一句话里有三个要点：1.什么是Spring-Messaging？ 2. 什么是WebSocket？3. 什么是STOMP？ </p>
<h3 id="Spring-Messaging"><a href="#Spring-Messaging" class="headerlink" title="Spring-Messaging"></a>Spring-Messaging</h3><p>Spring Messaging是Spring4.0为了集成JMS发布的一个新模块，为集成messaging API和消息协议提供支持，属于Spring Framework项目。其代码结构如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring-messaging模块  = base</span><br><span class="line">					| converter</span><br><span class="line">					| core</span><br><span class="line">					| handler</span><br><span class="line">					| simp</span><br><span class="line">					| support</span><br><span class="line">					| tcp</span><br></pre></td></tr></table></figure>
<p>这个漏洞主要涉及simp部分。</p>
<p>这里我们需要引入消息代理和消息队列的概念。</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 协议提供了通过一个套接字实现全双工通信的功能。也能够实现 web浏览器和server间的异步通信，全双工意味着server与浏览器间可以发送和接收消息。</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>
</blockquote>
<p>由于HTTP具有无状态，单向请求的特性，使得Server向Client推送消息变得非常繁琐，需要使用轮询的方式（定时一遍遍的询问服务器有没有新的消息），效率非常低，非常浪费资源。WebSocket就在这个时候应运而生。</p>
<p>比较通俗易懂的说，WebSocket就像聊天室模式。Client向Server发起建立WebSocket的请求，一旦建立成功，就像点开了微信的会话窗口。在这个会话中，Client可以说话，Server也可以说话。这样的模式下使Server向Client推送消息变得简单可行。</p>
<p>所以WebSocket是一种在一个TCP连接上能够全双工，双向通信的协议。它是一种与HTTP不同的协议，但是以HTTP作为载体的。主要使用80（ws://）和443（wss://）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">扩展：</span><br><span class="line">WebSocket是如何建立一次连接的呢？</span><br><span class="line"></span><br><span class="line">WebSocket的交互从一个带有Upgrade头的HTTP的HTTP Request开始，转换成WebSocket协议，向下面这样：</span><br><span class="line"></span><br><span class="line">GET /spring-websocket-portfolio/portfolio HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==</span><br><span class="line">Sec-WebSocket-Protocol: v10.stomp, v11.stomp</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://localhost:8080</span><br><span class="line"></span><br><span class="line">如果请求的端口支持WebSocket协议，返回101，表示成功建立一个WebSocket会话，向下面这样：</span><br><span class="line"></span><br><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=</span><br><span class="line">Sec-WebSocket-Protocol: v10.stomp</span><br></pre></td></tr></table></figure>
<h4 id="STOMP-Over-WebSocket"><a href="#STOMP-Over-WebSocket" class="headerlink" title="STOMP Over WebSocket"></a>STOMP Over WebSocket</h4><p>STOMP (Simple (or Streaming) Text Oriented Message Protocol ) 是一种在客户端与中转服务端之间进行异步消息传输的简单通用协议;。它定义了服务端与客户端之间的格式化文本传输方式。</p>
<p>STOMP是一个简单的协议，这个协议可以有多种载体，可以通过HTTP，也可以通过WebSocket。在Spring-Message中使用的是STOMP Over WebSocket。<br>现在Client和Server已经有了一个会话。现在我们需要规定一种格式，能够让两边都理解说的是什么，这个东西就是通过STOMP来统一的。就好像在一个微信聊天里，我们规定聊天的双方都是用汉语交流，如果一个是用汉语，一个是用阿拉伯语，双方都不知道对方讲的是什么，那么这个天就聊不下去了。</p>
<h5 id="STOMP-amp-amp-Message-Queue"><a href="#STOMP-amp-amp-Message-Queue" class="headerlink" title="STOMP &amp;&amp; Message Queue"></a>STOMP &amp;&amp; Message Queue</h5><p>STOMP的每一个包简单的来说是由三个部分组成： COMMAND Header Body<br>结构可以简化如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1</span><br><span class="line">header2:value2</span><br><span class="line"></span><br><span class="line">Body</span><br></pre></td></tr></table></figure>
<p>一共有这么几个COMMAND</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">client-command      = &quot;SEND&quot;</span><br><span class="line">                      | &quot;SUBSCRIBE&quot;</span><br><span class="line">                      | &quot;UNSUBSCRIBE&quot;</span><br><span class="line">                      | &quot;BEGIN&quot;</span><br><span class="line">                      | &quot;COMMIT&quot;</span><br><span class="line">                      | &quot;ABORT&quot;</span><br><span class="line">                      | &quot;ACK&quot;</span><br><span class="line">                      | &quot;NACK&quot;</span><br><span class="line">                      | &quot;DISCONNECT&quot;</span><br><span class="line">                      | &quot;CONNECT&quot;</span><br><span class="line">                      | &quot;STOMP&quot;</span><br><span class="line"></span><br><span class="line">server-command      = &quot;CONNECTED&quot;</span><br><span class="line">                      | &quot;MESSAGE&quot;</span><br><span class="line">                      | &quot;RECEIPT&quot;</span><br><span class="line">                      | &quot;ERROR&quot;</span><br></pre></td></tr></table></figure>
<p>Stomp协议中有两个重要的角色：STOMP客户端与任意STOMP消息代理（Broker）。如下图：</p>
<p><img src="/media/15245051361870.jpg" alt=""></p>
<p>STOMP是如何进行订阅的？<br>客户端使用SUBSCRIBE订阅命令，向Stomp服务代理订阅某一个虚拟路径上的监听。这样当其它客户端使用SEND命令发送内容到这个路径上时，这个客户端就可以收到这个消息。在使用SUBSCRIBE时，有一个重要的ACK属性。这个ACK属性说明了Stomp服务代理端发送给这个客户端的消息是否需要收到一个ACK命令，才认为这个消息处理成功了。</p>
<h4 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h4><p>Message Queue（消息队列）是一种应用程序对应用程序的通信方法。应用程序通通过读写出入队列的消息来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，排队指的是应用程序通过队列来通信。队列的使用除去了接受和发送应用程序同时执行的要求。</p>
<p>简单来说消息队列就相当于一个书架，在书架上有人放书有人拿书，但是放书的人和拿书的人互不通信。书架起到了一个中间人的作用。</p>
<p>通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。</p>
<p>   <strong>Broker：消息服务器，作为server提供消息核心服务</strong></p>
<p>   <strong>Producer:消息生产者，业务的发起方，负责生产消息传输给broker</strong></p>
<p>   <strong>Consumer：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</strong></p>
<p>   <strong>Queue：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</strong></p>
<p>   <strong>Message：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</strong></p>
<p>消息队列是一种技术手段，而消息代理是这种技术手段的一种实现方案。比较常见的消息代理有RabbitMQ，ActiveMQ等。</p>
<hr>
<p>我们再回到Spring，Spring 的消息功能是基于消息代理（broker）构建的。我们在这里使用这个Spring官方的Demo作为POC。<br><code>https://github.com/spring-guides/gs-messaging-stomp-websocket</code><br>完整的Demo代码在complete文件夹中，其中complete/src/main/resouces/static/app.js为STOMP的Client。<br>建立连接的代码如图所示。在这里可以看到，SockJS与/gs-guide-websocket建立连接，通过/topic/greetings订阅消息，而发送消息到/app/hello这个接口。</p>
<p><img src="/media/15244903372981.jpg" alt=""></p>
<p><img src="/media/15244904521856.jpg" alt=""></p>
<p>app.js中为什么出现三个接口？<br>第一个接口（“/gs-guide-websocket”）是建立STOMP连接，使用由SockJS实现的Websocket，在这里是由SockJS包装的Websocket，所以使用的是Stomp.over(ws)。如果使用原生的Websockets就使用Stomp.client(url)<br>第二个接口（“/topic/greetings”）利用STOMP的subscribe()让客户端进行订阅。这个方法有两个必要的参数：目的地（destination），回调函数（callback），还有一个可选的参数headers。其中destination是String类型，对应目的地，回调函数是伴随着一个参数的function类型<br>第三个接口（”/app/hello“）利用STOMP的send()来发送STOMP消息，请求向所有订阅过”/topic/greetings“的客户端推送消息。这个方法必须有一个参数，用来描述对应的STOMP的目的地，另外可以有两个可选的参数：headers，object类型包含额外的信息头部：body，一个String类型的参数。</p>
<p>这里有两个知识点SockJS的Fallback和Spring-Message的消息传递。</p>
<h4 id="SockJS-Fallback"><a href="#SockJS-Fallback" class="headerlink" title="SockJS Fallback"></a>SockJS Fallback</h4><p>由于公网环境比较复杂，一些不可控的代理可能会限制WebSocket的交互，一般分为两种情况，一种为不允许带有WebSocket的<code>Upgrade</code>头的HTTP Request通过，另一种是不允许闲置的长连接。<br>当然了，这个问题肯定是有解决办法的，比如使用WebSocket建立连接，然后使用HTTP的一些去模拟WebSocket交互，并且提供同一应用层的API。<br>SockJS就是为了解决这种问题而诞生的。</p>
<blockquote>
<p>The goal of SockJS is to let applications use a WebSocket API but fall back to non-WebSocket alternatives when necessary at runtime, i.e. without the need to change application code.</p>
</blockquote>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>消息传递是进程间数据传递的一种方法，进程采用消息(message)的方法，由发送进程向接收进程的消息队列发送一个消息，接收进程在合适的时候取出。</p>
<p>消息是异步发送的，客户端不需要等待服务处理消息，甚至不需要等待消息投递完成。客户端发送消息，然后继续执行，这个是因为客户端假定服务最终可以收到并处理这条信息。</p>
<p> 在异步消息中有两个主要的概念：消息代理(message broker)和目的地(destination)。当一个应用发送消息时，会将消息交给一个消息代理。消息大理可以确保消息被投递到指定的目的地，同事解放发送者，使其能够继续进行其他的业务。目的地只关注消息应该从哪里获得，而不关心由谁取走消息。</p>
<p> Spring-Message 消息传递<br> <img src="/media/15245051669811.jpg" alt=""></p>
<h3 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h3><p>Spring Expression Language (SpEL)是一种表达式语言，是一种可以与一个基于Spring的应用程序中的运行时对象交互的东西。有点类似于ognl表达式。总得来说SpEL表达式是一种简化开发的表达式，通过使用表达式来简化开发，减少一些逻辑、配置的编写。</p>
<p>SpEL具有很高的权限，可以执行任意命令。<br><img src="/media/15245036532267.jpg" alt=""></p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>给src/resources/static/app.js中的connect方法中调用的subscribe方法传入一个selector。exec()中执行任意命令。<br><img src="/media/15244957366325.jpg" alt=""></p>
<p><img src="/media/Jietu20180423-230615-HD.gif" alt="Jietu20180423-230615-HD"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Client建立WebSocket连接后点击connect按钮发送CONNECT和SUBSCRIBE。<br><img src="/media/15244969620658.jpg" alt=""><br>SUBSCRIBE已经将payload发送至服务器，但是并没有触发，而是在发送消息（SEND）时触发。<br>Spring Farmework处理订阅的逻辑在org.springfarmework:spring-messaging下，代码路径如图所示。<br><img src="/media/15244972788857.jpg" alt=""><br>在这个类下的addSubscriptionInternal方法处设置断点，点击connect按钮，可以看见以下信息。</p>
<p><img src="/media/15245025020813.jpg" alt=""></p>
<p>selector中的SpEL语句已经生成SpEL表达式（红框中）。还有此次会话的sessionid，后面将会通过sessionid取出消息。<br>一直跟进expression变量，传递关系为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps: ClassName.MethodName</span><br><span class="line"></span><br><span class="line">SessionSubscriptionRegistry.addSubscription -&gt; SessionSubscriptionInfo.addSubscription -&gt; Subscription.Subscription</span><br></pre></td></tr></table></figure>
<p>在Subscription的构造方法中将selector写进Subscription对象的属性中。<br><img src="/media/15244980412399.jpg" alt=""><br>返回的Subscription对象在SessionSubscriptionInfo.addSubscription中通过add方法添加到subs中。<br><img src="/media/15244982772540.jpg" alt=""></p>
<p>接下来，发送数据。Spring给消息订阅者分发消息的逻辑在org.springframework.messaging:simp/broker/SimpleBrokerMessageHandler.java中的sendMessageToSubscribers方法。<br>在<code>this.subscriptionRegistry.findSubscriptions(message)</code>方法下断点，可以看到传进来的message对象包含连接的信息。<br><img src="/media/15245026259276.jpg" alt=""></p>
<p>跟进<code>message</code>变量<br>调用链为 ： <code>this.subscriptionRegistry.findSubscriptions -&gt; findSubscriptionsInternal -&gt; filterSubscriptions</code><br>在filterSubscriptions方法中获取连接配置，包括SpEL表达式。<br><img src="/media/15245016958214.jpg" alt=""></p>
<p>红框处为获取连接配置的语句，其中含有我们的Payload（SpEL表达式）。<br><img src="/media/15245017761103.jpg" alt=""></p>
<p>下面的try语句中执行表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    if (Boolean.TRUE.equals(expression.getValue(context, Boolean.class)))   </span><br><span class="line">    &#123;</span><br><span class="line">        result.add(sessionId, subId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><img src="/media/15247240285757.jpg" alt=""><br>使用<code>SimpleEvaluationContext</code>代替具有任意命令执行权限的<code>StandardEvaluationContext</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于场景比较特殊，黑盒测试了数个Spring后台，并没有很好的效果。但是让研究人员的关注点转到了SpEL上，不失为一件好事。CTF中遇见Java的情况并不多，但是在实际工作中大部分的后台还是Java。近期会陆续分析一些Java的洞，学习一下Java相关的知识。</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><blockquote>
<p><a href="https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#expressions" target="_blank" rel="external">https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#expressions</a><br><a href="https://github.com/sockjs/sockjs-client/" target="_blank" rel="external">https://github.com/sockjs/sockjs-client/</a><br><a href="https://paper.seebug.org/562/" target="_blank" rel="external">https://paper.seebug.org/562/</a><br><a href="https://blog.csdn.net/pacosonswjtu/article/details/51914567" target="_blank" rel="external">https://blog.csdn.net/pacosonswjtu/article/details/51914567</a><br><a href="https://github.com/spring-guides/gs-messaging-stomp-websocket" target="_blank" rel="external">https://github.com/spring-guides/gs-messaging-stomp-websocket</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-spring-boot-basics-perry/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-spring-boot-basics-perry/index.html</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a><br><a href="https://www.websocket.org/aboutwebsocket.html" target="_blank" rel="external">https://www.websocket.org/aboutwebsocket.html</a></p>
</blockquote>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Analysis" >
    <span class="tag-code">Analysis</span>
  </a>

  <a href="/tags#Java" >
    <span class="tag-code">Java</span>
  </a>

  <a href="/tags#Spring" >
    <span class="tag-code">Spring</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#写给0基础的CVE-2018-1270分析"><span class="toc-nav-text">写给0基础的CVE-2018-1270分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#写在前面"><span class="toc-nav-text">写在前面</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#基础知识"><span class="toc-nav-text">基础知识</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Spring"><span class="toc-nav-text">Spring</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Spring-Messaging"><span class="toc-nav-text">Spring-Messaging</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#WebSocket"><span class="toc-nav-text">WebSocket</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#STOMP-Over-WebSocket"><span class="toc-nav-text">STOMP Over WebSocket</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#STOMP-amp-amp-Message-Queue"><span class="toc-nav-text">STOMP && Message Queue</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Message-Queue"><span class="toc-nav-text">Message Queue</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#SockJS-Fallback"><span class="toc-nav-text">SockJS Fallback</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#消息传递"><span class="toc-nav-text">消息传递</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#SpEL"><span class="toc-nav-text">SpEL</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#复现"><span class="toc-nav-text">复现</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#分析"><span class="toc-nav-text">分析</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#修复"><span class="toc-nav-text">修复</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#总结"><span class="toc-nav-text">总结</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#资料"><span class="toc-nav-text">资料</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://whip1ash.github.io/2018/04/17/CVE-2018-1270/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "whip1ash";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "写给0基础的CVE-2018-1270分析",
        owner: "whip1ash",
        repo: "whip1ash.github.io",
        oauth: {
          client_id: "ae16d933c78b6cc642c8",
          client_secret: "e9045e51de8f846b89b22e347cd34d1fe345c533"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>